为了让某个数据结构能够在网络上传输或能够保存至文件，它必须被编码然后再解码。当然已经有许多可用的编码方式了，比如 JSON、XML、Google 的 protocol buffers 等等。
而现在又多了一种，由Go语言 encoding/gob 包提供的方式。

Gob 是Go语言自己以二进制形式序列化和反序列化程序数据的格式，可以在 encoding 包中找到。这种格式的数据简称为 Gob（即 Go binary 的缩写）。
类似于 Python 的“pickle”和 Java 的“Serialization”。

Gob 和 JSON 的 pack 之类的方法一样，由发送端使用 Encoder 对数据结构进行编码。在接收端收到消息之后，接收端使用 Decoder 将序列化的数据变化成本地变量。

Go语言可以通过 JSON 或 Gob 来序列化 struct 对象，虽然 JSON 的序列化更为通用，但利用 Gob 编码可以实现 JSON 所不能支持的 struct 的方法序列化，
利用 Gob 包序列化 struct 保存到本地也十分简单。

Gob 不是可外部定义、语言无关的编码方式，它的首选的是二进制格式，而不是像 JSON 或 XML 那样的文本格式。Gob 并不是一种不同于 Go 的语言，
而是在编码和解码过程中用到了 Go 的反射。

Gob 通常用于远程方法调用参数和结果的传输，以及应用程序和机器之间的数据传输。它和 JSON 或 XML 有什么不同呢？Gob 特定的用于纯 Go 的环境中，
例如两个用Go语言写的服务之间的通信。这样的话服务可以被实现得更加高效和优化。

Gob 文件或流是完全自描述的，它里面包含的所有类型都有一个对应的描述，并且都是可以用Go语言解码，而不需要了解文件的内容。

只有可导出的字段会被编码，零值会被忽略。在解码结构体的时候，只有同时匹配名称和可兼容类型的字段才会被解码。当源数据类型增加新字段后，
Gob 解码客户端仍然可以以这种方式正常工作。解码客户端会继续识别以前存在的字段，并且还提供了很大的灵活性，比如在发送者看来，
整数被编码成没有固定长度的可变长度，而忽略具体的 Go 类型。

假如有下面这样一个结构体 T：

    type T struct { X, Y, Z int }
    var t = T{X: 7, Y: 0, Z: 8}

而在接收时可以用一个结构体 U 类型的变量 u 来接收这个值：

type U struct { X, Y *int8 }
var u U

在接收时，X 的值是 7，Y 的值是 0（Y 的值并没有从 t 中传递过来，因为它是零值）和 JSON 的使用方式一样，
Gob 使用通用的 io.Writer 接口，通过 NewEncoder() 函数创建 Encoder 对象并调用 Encode()，
相反的过程使用通用的 io.Reader 接口，通过 NewDecoder() 函数创建 Decoder 对象并调用 Decode 。    

### 创建 gob 文件
下面通过简单的示例程序来演示Go语言是如何创建 gob 文件的，代码如下所示：

+ 案例
 * 1.go
